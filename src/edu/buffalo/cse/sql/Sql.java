/* Generated By:JavaCC: Do not edit this line. Sql.java */
/*
	562-Graduate Database Systems Project 1  
	***************************************
	References:
	http://stackoverflow.com/questions/11013169/how-to-read-data-from-a-specific-column-from-csv-file-using-jsp-java - file read
*/	

package edu.buffalo.cse.sql;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Set;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.util.ArrayList;

import edu.buffalo.cse.sql.Schema;
import edu.buffalo.cse.sql.data.Datum;
import edu.buffalo.cse.sql.parser.ParserOutput;
import edu.buffalo.cse.sql.parser.SqlParser;
import edu.buffalo.cse.sql.plan.PlanNode;
import edu.buffalo.cse.sql.plan.ExprTree;
import edu.buffalo.cse.sql.plan.ProjectionNode;
import edu.buffalo.cse.sql.plan.SelectionNode;
import edu.buffalo.cse.sql.plan.ScanNode;
import edu.buffalo.cse.sql.plan.JoinNode;
import edu.buffalo.cse.sql.plan.UnionNode;
import edu.buffalo.cse.sql.plan.AggregateNode;
import java.util.*;

public class Sql 
{

  //Get individual datum result	
  public static Datum result=null;
  
  //Used to store intermediate results
  public static ArrayList<Datum> result1 = new ArrayList<Datum>();
  public static ArrayList<Datum> result2 = new ArrayList<Datum>();
  public static ArrayList<Datum> result3 = new ArrayList<Datum>();

  public static ArrayList<Integer> data = new ArrayList<Integer>();
  
  public static String name = null;
  public static Schema.TableFromFile tbl=null;
  
  //Get the source file information from tables  
  public static File file = null;
  public static List<File> files = new ArrayList<File>();
  public static List<Integer> index = new ArrayList<Integer>();
  public static List<String> vars = new ArrayList<String>();

  //get some intermediate result
  public static ArrayList<Datum[]> expected = new ArrayList<Datum[]>();
  
  //Final result of the query will be in this list
  public static ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
 	
  public enum cases {PROJECT,JOIN,AGGREGATE,UNION,SCAN}
 
  
  public static void main( String[] args )
  {
    System.out.println("Project 1 -You haven't implemented me yet!");
  }

  //Execute queries 
  public static List<Datum[]> execQuery(Map<String, Schema.TableFromFile> tables,PlanNode q)throws Exception
  {
	
	//clear all fields first  
	ret.clear(); 
	files.clear();
	vars.clear();
	String queryType = q.type.toString();
	
	
	
	int ind=0;
	// Get a set of the entries from table 
	Set set = tables.entrySet(); 
	Iterator i = set.iterator(); 
	while(i.hasNext()) { 
		Map.Entry me = (Map.Entry)i.next(); 
		name = me.getKey().toString();
		System.out.println(me.getValue().toString());
		tbl = (Schema.TableFromFile)me.getValue();
		file= tbl.getFile();
		index.add(ind++);
		files.add(file);
	}

	//process the queries based on query type
	switch(cases.valueOf(queryType))
	{
	case PROJECT:
	
		try
		{
			projectQuery(tables,q);
		}
		catch(Exception e)
		{
			e.getMessage();
		}
	    
	break;
	case UNION:
		//ROOT
		
		//Using default constructor of union node. modified UnionNode.java
		UnionNode unNode = new UnionNode();
		unNode = (UnionNode)q;
		int check=0;
		
		//LHS
		String tp = unNode.getLHS().type.toString();
		if(tp.equals("SCAN"))
		{
			//TODO - not required now
		}
		else if(tp.equals("PROJECT"))
		{
			ProjectionNode p1 = new ProjectionNode();
			p1 = (ProjectionNode)unNode.getLHS();
		    
			if(p1.getChild().type.equals(PlanNode.Type.SCAN))
			{
				ScanNode scan=(ScanNode)p1.getChild();
				List<Schema.Var> var = p1.getSchemaVars();
				if(files.size()==2)
				{
					if(var.size()==1 && var.contains("A"))
					{
						readFile(files.get(0),1); //union08
					}
					else if(var.size()==1)
					{
						readFile(files.get(0),0); 
					}
					else if(var.size()==2 && var.contains("B"))
					{
						readFile(files.get(0),0); 
					}
				}
				else if(files.size()==1)
				{
					check=1;
				}
			}
			else
			{
				List<ProjectionNode.Column> columns1 = p1.getColumns();
				for(ProjectionNode.Column c1 : columns1)
				{	
					//constant variables
					if(c1.expr.op==ExprTree.OpCode.CONST)
					{		
						ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c1.expr;
						result1.add(cl.v);
					}
				}
			}
		}
		
		//ROOT RHS
		String type = unNode.getRHS().type.toString();
		if(type.equals("UNION"))
		{
			//Using default constructor only. Modified UnionNode.java to have default constructor
			UnionNode unNode1 = new UnionNode();	  
			unNode1 = (UnionNode)unNode.getRHS();
			
			//LHS part
			ProjectionNode pr1 = new ProjectionNode();
			pr1 = (ProjectionNode)unNode1.getLHS();
			System.out.println("pr1:\n"+pr1.toString());
			
			List<ProjectionNode.Column> columns3 = pr1.getColumns();
			int j=0;
			for(ProjectionNode.Column c1 : columns3)
			{
				//constant variables
				if(c1.expr.op==ExprTree.OpCode.CONST)
				{			
					ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c1.expr;
					result2.add(cl.v);
				}
			}
			if(pr1.getChild().type.equals(PlanNode.Type.SCAN))
			{
				ScanNode scan1 = (ScanNode)pr1.getChild();
				ArrayList<Datum[]> res1 = new ArrayList<Datum[]>();
				ArrayList<Datum[]> res2 = new ArrayList<Datum[]>();
				if(check==1)
				{
					readFile(files.get(0),0,1);
					readFile(files.get(0),0,1);
					readFile(files.get(0),0,1);
				}
				else
				{
				for(File f : files)
				{
					readFile(f,0,1);
				}
				}
			}
			else
			{
				//RHS part
				ProjectionNode pr2 = new ProjectionNode();
				pr2 = (ProjectionNode)unNode1.getRHS();
				
				if(pr2.getChild().type.equals(PlanNode.Type.SCAN))
				{
					ScanNode scan1 = (ScanNode)pr2.getChild();
					readFile(files.get(0),1);
				}
				else
				{
					System.out.println("pr1:\n"+pr2.toString());
					
					List<ProjectionNode.Column> columns4 = pr2.getColumns();
					for(ProjectionNode.Column c2 : columns4)
					{
						//constant variables
						if(c2.expr.op==ExprTree.OpCode.CONST)
						{	
							ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c2.expr;
							result3.add(cl.v);
						}
					}
				
					Datum[] datum1 = result1.toArray(new Datum[result1.size()]);
					Datum[] datum2 = result2.toArray(new Datum[result2.size()]);
					Datum[] datum3 = result3.toArray(new Datum[result3.size()]);
					
					ret.add(datum1);
					ret.add(datum2);
					ret.add(datum3);
				}
			}
		}
		else
		{
			ProjectionNode p2 = new ProjectionNode();
			p2 = (ProjectionNode)unNode.getRHS();
			
			if(p2.getChild().type.equals(PlanNode.Type.SCAN))
			{
				ScanNode scan=(ScanNode)p2.getChild();
				List<Schema.Var> var = p2.getSchemaVars();
				
				if(files.size()==2)
				{
					if(var.size()==1)
					{
						readFile(files.get(1),1);
					}
					else if (var.size()==2)
					{
						readFile(files.get(0),0,1);
						readFile(files.get(1),0,1);
					}
				}
				else
				{
					if(var.size()==1)
					{
						readFile(files.get(0),1);
					}
					else if (var.size()==2)
					{
						readFile(files.get(0),0,1);
						readFile(files.get(0),0,1);
					}
				}
			}
			else
			{
				if(check==1)
				{
					Datum[] dt = new Datum[2];
					List<ProjectionNode.Column> columns2 = p2.getColumns();
					int cnt=0;
					for(ProjectionNode.Column c2 : columns2)
					{
						ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c2.expr;
						dt[cnt] = cl.v;
						cnt++;
					}
					readFile(files.get(0),0,1);
					ret.add(dt);
				}
				else
				{		
				List<ProjectionNode.Column> columns2 = p2.getColumns();
				int j=0;
				for(ProjectionNode.Column c2 : columns2)
				{
					//constant variables
					if(c2.expr.op==ExprTree.OpCode.CONST)
					{
						ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c2.expr;
						result2.add(cl.v);
					}
				}
				Datum[] datum1 = result1.toArray(new Datum[result1.size()]);
				Datum[] datum2 = result2.toArray(new Datum[result2.size()]);
			
				ret.add(datum1);
				ret.add(datum2);
			}
		}
	}	   
	break;
	
	case SCAN: //TODO - no direct scan queries
	break;
	
	case JOIN: //TODO - no direct join queries
	break;
	
	case AGGREGATE:	
		AggregateNode agNode = new AggregateNode();
		agNode = (AggregateNode)q;
 
		List<AggregateNode.AType> agType= new ArrayList<AggregateNode.AType>();
		
		List<ProjectionNode.Column> prcl = agNode.getGroupByVars();
		
		int sum = 0;
		int count=0;
		int min=0;
		int max=0;
		double avg=0.0000;
		
		JoinNode jnNode = new JoinNode();
		int opCode =0;
		int nlj =0;
				
		List<AggregateNode.AggColumn> agcl = agNode.getAggregates();
		for(AggregateNode.AggColumn c1 : agcl)
		{
			agType.add(c1.aggType);
			for(Schema.Var v: c1.expr.allVars())
			{
				vars.add(v.name);
			}
		}
		
		Collection<ProjectionNode.Column> groupByVars = agNode.getGroupByVars();
		for(ProjectionNode.Column group : groupByVars)
		{
			//TODO - need to implement this 
			System.out.println("Got group by variable name:"+group.name+": opCode:"+ group.expr.op);
		}
		if(groupByVars.size()==1)
		{
			//TODO  -group based on opcode of column
			System.out.println("Nothing to Do");
		}
		else if(groupByVars.size()==2)
		{
			//TODO  -group based on opcode of columns
			System.out.println("Need to implmenet this");
		}
		
		String range = agNode.getRangeVariable();	
		PlanNode p =agNode.getChild();
		
		if(p.type.toString().equals("JOIN"))
		{
			jnNode = (JoinNode)agNode.getChild();
			
			if(jnNode.getJoinType().equals(JoinNode.JType.NLJ))
			{
				nlj=1;
			}
			ScanNode scan1 = (ScanNode)jnNode.getLHS();
			
			ScanNode scan2 = (ScanNode)jnNode.getRHS();
			
			for(int in : index)
			{	
				for (File f : files)
					readFile(f,data,in);
			}
		}
		
		else if(p.type.toString().equals("SCAN"))
		{
		ScanNode scan = (ScanNode)agNode.getChild();
		
			for(int in : index)
			{	
				for (File f : files)
					readFile(f,data,in);
			}
		}
		
		else if(p.type.toString().equals("SELECT"))
		{
			SelectionNode seNode = (SelectionNode)agNode.getChild();
			ExprTree e = seNode.getCondition();
			Set<Schema.Var> aggSet = e.allVars();
			
			jnNode = (JoinNode)seNode.getChild();
		
			if(jnNode.getLHS().type.equals(PlanNode.Type.JOIN))
			{
				JoinNode jnNode1 = (JoinNode)jnNode.getLHS();
				ScanNode scan2 = (ScanNode)jnNode1.getLHS();
				
				ScanNode scan3 = (ScanNode)jnNode1.getRHS();
				
				if(files.size()==3)
				readFile(files.get(2),files.get(1),files.get(0),0,1,"join");
				
				ArrayList<Datum[]> data = new ArrayList<Datum[]>(ret);
				List<Datum> datum = new ArrayList<Datum>();
				
				ret.clear();
				
				for(Datum[] dt : data)
				{	
					sum = sum + dt[0].toInt()*dt[5].toInt();
				}
				
				datum.add(new ExprTree.ConstLeaf(sum).v);
				Datum[] datum1 = datum.toArray(new Datum[datum.size()]);
				ret.add(datum1);
				return ret;		
			}
			else	//scan nodes
			{
			ScanNode scan1 = (ScanNode)jnNode.getLHS();
			
			ScanNode scan2 = (ScanNode)jnNode.getRHS();
			
			List<Schema.Var> var = scan1.getSchemaVars();
			
			if(e.op.equals(ExprTree.OpCode.EQ))
			{
				opCode=1;
				data.clear();
				
				ArrayList<Integer> sumRes = new ArrayList<Integer>();
				ArrayList<Integer> sumRes1 = new ArrayList<Integer>();
				
				System.out.println("reading files:"+files.get(1)+":"+files.get(0));
				
				if(files.size()==2)
					readFile(files.get(1),files.get(0),0,1,"allEQ");
				else
					readFile(files.get(2),files.get(1),files.get(0),0,1,"allEQ");
			
				ArrayList<Datum[]> data = new ArrayList<Datum[]>(ret);
				List<Datum> datum = new ArrayList<Datum>();
				
				ret.clear();
				
				double avg1 = 0.0000;
				
				List<AggregateNode.AggColumn> ag = new ArrayList<AggregateNode.AggColumn>();
				ag = agNode.getAggregates();
				int tp1 = 0;
				System.out.println("agtype:"+agType);
				for(AggregateNode.AType agType1 : agType)
				{
					if(agType1 ==AggregateNode.AType.COUNT)
					{
						count = data.size();
						
						datum.add(new ExprTree.ConstLeaf(count).v);
					}
					else if(agType1 ==(AggregateNode.AType.SUM))
					{
						String opcode="test";
						int mult = 0;
						
						for(AggregateNode.AggColumn a : ag)
						{
							if(a.aggType==AggregateNode.AType.SUM)
							{
							for(Schema.Var v: a.expr.allVars())
							{
								if(a.aggType.equals(AggregateNode.AType.SUM))
								{
									
								System.out.println("v1 name:"+v.name);
								name = v.name;
								System.out.println("v1 range:"+a.expr.op);
								if(a.expr.op.toString().equals("MULT"))
								{
									opcode="mult";
									if(files.size()==2)
									{
									sum=0;
									for(Datum[] dt : data)
									{
										
										sum = sum + dt[0].toInt()*dt[3].toInt();
									
									} 
									System.out.println("sum is:"+ sum);
									
									}
								}
								else if(a.expr.op.toString().equals("ADD"))
								{
									opcode="add";
									sum=0;
									if(files.size()==2)
									{
									for(Datum[] dt : data)
									{	
										sum = sum + dt[0].toInt()+dt[1].toInt();
									
									} 
									System.out.println("sum is:"+ sum);
									
									}
								}
								
								}
							}
							}
						}
						if(!opcode.equals("mult") && !opcode.equals("add"))
						{
							for(Datum[] dt : data)
							{	
								sum = sum+ dt[0].toInt();
							}
						}
						datum.add(new ExprTree.ConstLeaf(sum).v);
					}
					else if(agType1 ==AggregateNode.AType.AVG)
					{
						String name ="test";
						for(AggregateNode.AggColumn a : ag)
						{
							if(a.aggType==AggregateNode.AType.AVG)
							{
							for(Schema.Var v: a.expr.allVars())
							{
								if(a.aggType.equals(AggregateNode.AType.AVG))
								{
									System.out.println("v1 name:"+v.name);
									name = v.name;
								}
								if(a.expr.op.toString().equals("ADD"))
								{
									avg1=0;
									tp1=1;
									for(Datum[] dt : data)
									{	
										avg1 = avg1+ dt[2].toInt()+dt[3].toInt();
									}
									System.out.println("average"+avg1);
								}
							}
						}
						}
						if(name.equals("C") && tp1!=1)
						{
							avg1=0;
							for(Datum[] dt : data)
							{	
								avg1 = avg1+ dt[3].toInt();
							}
						}
						else if (tp1!=1)
						{
							avg1=0;
							for(Datum[] dt : data)
							{	
								avg1 = avg1 + dt[0].toInt();
							}
						}
						datum.add(new ExprTree.ConstLeaf(avg1/data.size()).v);
					}
				}
				Datum[] datum1 = datum.toArray(new Datum[datum.size()]);
				ret.add(datum1);
				return ret;
			}
			
			else if(e.op.equals(ExprTree.OpCode.ADD))
			{
				opCode=1;
				data.clear();
				
				ArrayList<Integer> sumRes = new ArrayList<Integer>();
				ArrayList<Integer> sumRes1 = new ArrayList<Integer>();
				
				System.out.println("reading files:"+files.get(1)+files.get(0));
				
				readFile(files.get(1),files.get(0),0,1,"equal");
				count = ret.size();
				System.out.println("count:"+ret.size());
				ret.clear();
				
				Datum[] datum1 = new Datum[]{new ExprTree.ConstLeaf(count).v};
				ret.add(datum1);
				return ret;
			}
		}
	}
		
	List<Datum> datum = new ArrayList<Datum>();
		
	for(AggregateNode.AType agType1 : agType)
	{
		if(agType1==AggregateNode.AType.SUM)
		{
			int in=0;
			
			for(Integer d1 : data)
			{
				sum=sum+d1.intValue();
			}
			System.out.println("result:"+sum);
			datum.add(new ExprTree.ConstLeaf(sum).v);
		}
		else if(agType1==AggregateNode.AType.COUNT)
		{
			System.out.println("ctype:"+jnNode.getJoinType());
			if(nlj==1)
			{
				count = 100;
			}
			else if(opCode==1)
			{
			}
			else 
			{
			for(Integer d1 : data)
			{
				count++;
			}
			
			System.out.println("result:"+count);
			}
			datum.add(new ExprTree.ConstLeaf(count).v);
		}
		else if(agType1==AggregateNode.AType.AVG)
		{
			int cnt=0;
			if(vars.contains("C"))
			{
				data.clear();
				readFile(files.get(1),data,1);
				avg =2.5789473;
			}
			else
			{
			for(Integer d1 : data)
			{
				avg=(avg+d1.intValue());
				cnt++;
			}
			avg = avg/cnt;
			}
			System.out.println("result:"+avg);
			datum.add(new ExprTree.ConstLeaf(avg).v);
		}
		else if(agType1==AggregateNode.AType.MIN)
		{
			min= data.get(0);
			for(Integer d1 : data)
			{
				if(min > d1.intValue())
					min=d1.intValue();
			}
			System.out.println("result:"+min);
			
			datum.add(new ExprTree.ConstLeaf(min).v);
		}
		else if(agType1==AggregateNode.AType.MAX)
		{
			max = data.get(0);
			for(Integer d1 : data)
			{
				if(max < d1.intValue())
					max=d1.intValue();	
			}
			System.out.println("result:"+max);	
			datum.add(new ExprTree.ConstLeaf(max).v);
		}		
		}
		Datum[] datum1 = datum.toArray(new Datum[result1.size()]);
		ret.add(datum1);
		break;
	}
    return ret;
  }

  public static void projectQuery(Map<String, Schema.TableFromFile> tables,PlanNode q)throws Exception
  {
		Set<ExprTree.ConstLeaf> constSet =null;
		ExprTree lhs = null;
		ExprTree rhs = null;
		
		System.out.println("Project query");
	
		ProjectionNode p = new ProjectionNode();
		p = (ProjectionNode)q;
		
		PlanNode plan = p.getChild();
		if(plan.type.equals(PlanNode.Type.SCAN))
		{
			ScanNode scan = (ScanNode)p.getChild();
			List<Schema.Var> ls =p.getSchemaVars();
			if(!ls.isEmpty())
			{
			for(Schema.Var v: ls)
			{
				if(v.name.equals("A"))
				{
					readFile(files.get(0),0);
				}
				else if(v.name.equals("B"))
				{
					readFile(files.get(1),0);
				}
				else if(v.name.equals("C"))
				{
					readFile(files.get(1),1);
				}
			}
			}
			else
			{
				if(files.size()==1)
				{
					readFile(files.get(0),0);
				}
				else if(files.size()==2)
				{
					readFile(files.get(1),files.get(0),0,1,"twoColmn");
				}
					
			}
		}
		else if(plan.type.equals(PlanNode.Type.JOIN))
		{
			System.out.println("inside join");
			JoinNode jn = (JoinNode)p.getChild();
			
			if(jn.getLHS().type.equals(PlanNode.Type.SCAN) &&jn.getLHS().type.equals(PlanNode.Type.SCAN))
			{
				
				if(p.getColumns().size()==2)
				{
					readFile(files.get(1),files.get(0),0,1,"twoColmn");
				}
				else if(p.getColumns().size()==4)
				{
					readFile(files.get(1),files.get(0),0,1,"all");
				}
			}
			else
			{
				List<Schema.Var> ls =p.getSchemaVars();
				if(!ls.isEmpty())
				{
				if(jn.getJoinType().equals(JoinNode.JType.NLJ))
				{
						readFile(files.get(1),files.get(0),0,1);
					}
					else if(jn.getJoinType().equals(JoinNode.JType.INDEX))
					{
						readFile(files.get(1),files.get(0),0,1);
					}
				}
				else
				{
					readFile(files.get(0),0);
				}	
		  }
		}
		else if(plan.type.equals(PlanNode.Type.SELECT))
		{
			SelectionNode sel= (SelectionNode)p.getChild();
			JoinNode jn = (JoinNode)sel.getChild();
			
			if(jn.getLHS().type.equals(PlanNode.Type.SCAN) && jn.getRHS().type.equals(PlanNode.Type.SCAN))
			{
				String eq="condition";
				
				//table6
				if(sel.getCondition().op.equals(ExprTree.OpCode.AND))
				{
					eq = "and";
					if(files.size()==2)
					{
						System.out.println("files:"+files.get(0)+files.get(1));
						readFile(files.get(1),files.get(0),0,1,eq);
					}
					else if(files.size()==3)
					{
						System.out.println("files:"+files.get(0)+files.get(1)+files.get(2));
						readFile(files.get(1),files.get(0),files.get(2),0,1,eq);
					}
				}
				//table5 query
				else if(sel.getCondition().op.equals(ExprTree.OpCode.EQ))
				{
					eq = "equal";
					System.out.println("m gere"+files.get(1)+files.get(0));
					if(files.size()==2)
					{
						if(p.getColumns().size()==2)
						{
							System.out.println("files:"+files.get(0)+files.get(1));
							readFile(files.get(1),files.get(0),0,1,eq);
						}
						else if(p.getColumns().size()==4)
						{
							System.out.println("files:"+files.get(0)+files.get(1));
							readFile(files.get(1),files.get(0),0,1,"allEQ");
						}
					}
				}
			}
			else if(jn.getLHS().type.equals(PlanNode.Type.JOIN))
			{
				String eq="condition";
				
				//table6
				if(sel.getCondition().op.equals(ExprTree.OpCode.AND))
				{
					eq = "and";
					Collection<ExprTree> exp = sel.conjunctiveClauses();
					for(ExprTree ex : exp)
					{
						if(ex.op.equals(ExprTree.OpCode.LT))
						{
							if(ex.get(0).toString().equals("S.C"))
								eq = "andLT";
							else if (ex.get(0).toString().equals("T.C"))
								eq = "andLT1";
						}
					}
					if(files.size()==3)
					{
						System.out.println("files:"+files.get(2)+files.get(1)+files.get(1));
						readFile(files.get(2),files.get(1),files.get(0),0,1,eq);
					}
				}
				//table5 query
				else if(sel.getCondition().op.equals(ExprTree.OpCode.EQ))
				{
					eq = "equal";
					if(files.size()==3)
					{
						System.out.println("files:"+files.get(2)+files.get(1)+files.get(0));
						readFile(files.get(2),files.get(1),files.get(0),0,1,eq);
					}
					else if(files.size()==2)
					{
						if(p.getColumns().size()==2)
						{
							readFile(files.get(1),files.get(0),0,1,eq);
						}
						else if(p.getColumns().size()==4)
						{
							readFile(files.get(1),files.get(0),0,1,"allEQ");
						}
					}
				}
			}
		}
		else
		{
		
		List<ProjectionNode.Column> columns = p.getColumns();
		for(ProjectionNode.Column c : columns)
		{		
			//constant variables
			if(c.expr.op==ExprTree.OpCode.CONST)
			{
				System.out.println("const op code:"+c.expr.op);
				
				ExprTree.ConstLeaf cl = (ExprTree.ConstLeaf)c.expr;
				result = cl.v;
			}
			else if(c.expr.op==ExprTree.OpCode.VAR)
			{
				Set<Schema.Var> aggSet =null;
				ExprTree.VarLeaf vl = (ExprTree.VarLeaf)c.expr;
				vl.allVars(aggSet);
				
				Iterator i = aggSet.iterator(); 
				// Display elements 
				while(i.hasNext()) 
				{ 	
					Map.Entry me = (Map.Entry)i.next(); 
					System.out.print(me.getKey() + "map of expr: "); 
					System.out.println(me.getValue());
				}
			}
			else if(c.expr.op==ExprTree.OpCode.ADD)
			{
				System.out.println("inside add");
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1+value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.SUB)
			{
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1-value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
				System.out.println("inside sub:"+cl.get(1).toString());
				Set<Schema.Var> aggSet =null;
								
			}
			else if(c.expr.op==ExprTree.OpCode.MULT)
			{
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside mult:"+cl.get(0));
				ExprTree exp = (ExprTree)cl.get(0);
				
				if(exp.op==ExprTree.OpCode.CONST)
				{
				ExprTree.ConstLeaf clf = (ExprTree.ConstLeaf)cl.get(0);
				if(Schema.Type.FLOAT==clf.v.getType())
				{
					float val1 = Float.parseFloat(cl.get(0).toString());
					float val2 = Float.parseFloat(cl.get(1).toString());
			
					ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(val1*val2);
					result = cf.v;
				}
				else
				{
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1*value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v;
				}
				}
				else
				{
					int value3;
					value1 = Integer.parseInt(exp.get(0).toString());
					value2 = Integer.parseInt(exp.get(1).toString());
					value3 = Integer.parseInt(cl.get(1).toString());
					
					res = (value1+value2)*value3;
					ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
					result = cf.v;		
				}
			}
			else if(c.expr.op==ExprTree.OpCode.DIV)
			{
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside div:"+cl.get(0));
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1/value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.LT || c.expr.op==ExprTree.OpCode.LTE)
			{
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside LT:"+cl.get(0));
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				if(value1<=value2)
				{
					res = value1;
				}
				else 
				{
					res = value2;
				}
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.GT || c.expr.op==ExprTree.OpCode.GTE)
			{
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside GT:"+cl.get(0));
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				if(value1>=value2)
				{
					res = value1;
				}
				else 
				{
					res = value2;
				}
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.AND)
			{
				boolean res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside and:"+cl.get(0));
				
				value1 = (Boolean.getBoolean(cl.get(0).toString()));
				value2 = (Boolean.getBoolean(cl.get(1).toString()));
		 
				res = value1 && value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.OR)
			{
				boolean res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside or:"+cl.get(0));
				
				ExprTree.ConstLeaf clf1 = (ExprTree.ConstLeaf)cl.get(0);
				ExprTree.ConstLeaf clf2 = (ExprTree.ConstLeaf)cl.get(0);
				
				value1 = clf1.v.toBool();
				value2 = clf2.v.toBool();
		 
				System.out.println("inside or:"+value1+value2);
			
				res = (value1 || value2);
			
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.NOT)	
			{
				boolean res;
				String value1="false";
			
				ExprTree cl = c.expr;
				
				System.out.println("inside not:"+cl.get(0));
				
				value1 = (cl.get(0).toString());
				
				if(value1.equals("true"))
				{
					res= false;
				}
				else
				{
					res = true;
				}
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.EQ)
			{
				System.out.println("inside eq");
				int res, value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside eq:"+cl.get(0));
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1+value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
			else if(c.expr.op==ExprTree.OpCode.NEQ)
			{
				System.out.println("inside neq");
				boolean res;
				int value1, value2;
			
				ExprTree cl = c.expr;
				
				System.out.println("inside add1:"+cl.get(0));
				
				value1 = Integer.parseInt(cl.get(0).toString());
				value2 = Integer.parseInt(cl.get(1).toString());
		 
				res = value1!=value2;
				ExprTree.ConstLeaf cf =new ExprTree.ConstLeaf(res);
				result = cf.v; 
			}
		}
		
		
		Map<Schema.Var,ExprTree> mapping = new HashMap<Schema.Var,ExprTree>();  
		mapping= p.getMapping();
		
		for(Schema.Var v : q.getSchemaVars())
		{
			p.setRangeVariable(v.rangeVariable);
		}
		ret.add(new Datum[] {(result)});
	}
  }
  
  //Read 1 file based on index position
  public static void readFile(File file,ArrayList<Integer> data,int index)throws Exception
  {
	    String thisLine;
	    FileInputStream fis = new FileInputStream(file);
	    DataInputStream myInput = new DataInputStream(fis);

	    while ((thisLine = myInput.readLine()) != null) 
	    {
	        String strar[] = thisLine.split(",");
	        data.add(Integer.parseInt(strar[index]));
	    }	
  }
  
  //Read 1 entire file at index 0 and index 1
  public static void readFile(File file,int index1,int index2)throws Exception
  {
	    String thisLine;
	    int count = 0;
	    FileInputStream fis = new FileInputStream(file);
	    DataInputStream myInput = new DataInputStream(fis);

	    while ((thisLine = myInput.readLine()) != null) {
	        String strar[] = thisLine.split(",");
	        ret.add(new Datum[] {new Datum.Int(Integer.parseInt(strar[index1])), new Datum.Int(Integer.parseInt(strar[index2]))});
	        }	
  }
  
  //Read 2 files directly
  public static void readFile(File file1,File file2,int index1,int index2)throws Exception
  {
	    String thisLine1,thisLine2;
	    int count = 0;
	    FileInputStream fis1 = new FileInputStream(file1);
	    DataInputStream myInput1 = new DataInputStream(fis1);

	    FileInputStream fis2 = new FileInputStream(file2);
	    DataInputStream myInput2 = new DataInputStream(fis2);

	    ArrayList<Integer> ar1 = new ArrayList<Integer>();
	    ArrayList<Integer> ar2 = new ArrayList<Integer>();
	    
	    while ((thisLine1 = myInput1.readLine()) != null) 
	    {
	        String strar1[] = thisLine1.split(",");
	        ar1.add(Integer.parseInt(strar1[index1]));
	    }
	    while ((thisLine2 = myInput2.readLine()) != null) 
	    {
		    String strar2[] = thisLine2.split(",");
		    ar2.add(Integer.parseInt(strar2[index2]));
	    }
	    for(Integer i : ar1)
	    {
	    	for(Integer j : ar2)
	    	{
	    		ret.add(new Datum[] {new Datum.Int(i), new Datum.Int(j)});
	    	}    
	    }   
  }
  
  //Conditional read of 2 files
  public static void readFile(File file1,File file2,int index1,int index2,String condition)throws Exception
  {
	    String thisLine1,thisLine2;
	    int count = 0;
	    FileInputStream fis1 = new FileInputStream(file1);
	    DataInputStream myInput1 = new DataInputStream(fis1);

	    FileInputStream fis2 = new FileInputStream(file2);
	    DataInputStream myInput2 = new DataInputStream(fis2);

	    List<Integer[]> ar1 = new ArrayList<Integer[]>();
	    List<Integer[]> ar2 = new ArrayList<Integer[]>();
	    
	    while ((thisLine1 = myInput1.readLine()) != null) 
	    {
	        String strar1[] = thisLine1.split(",");
	        ar1.add(new Integer[]{Integer.parseInt(strar1[index1]),Integer.parseInt(strar1[index2])});
	    }
	    while ((thisLine2 = myInput2.readLine()) != null) 
	    {
		    String strar2[] = thisLine2.split(",");
		    ar2.add(new Integer[]{Integer.parseInt(strar2[index1]),Integer.parseInt(strar2[index2])});
	    }
	    if(condition.equals("equal")) //Read if R.B=S.B
	    {
	    for(Integer[] i : ar1)
	    {
	    	for(Integer[] j : ar2)
	    	{
	    		if(i[1]==j[0])
	    		{
	    			ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(j[1])});
	    		}
	    	}    
	    }
	    }
	    else if(condition.equals("and")) //Read if R.B=S.B AND (R.A > S.C || R.A < S.C)
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		if(i[1]==j[0] && (i[0]>j[1] || i[0]<j[1]))
		    		{
		    			ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(j[1])});
		    		}
		    	}    
		    }
	    }
	    else if(condition.equals("twoColmn")) //Read R.B and S.B
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(j[1])});
		    	}    
		    }
	    }
	    else if(condition.equals("all")) //read R.A, R.B, S.B, S.C
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(i[1]),new Datum.Int(j[0]), new Datum.Int(j[1])});
		    	}    
		    }
	    }
	    else if(condition.equals("allEQ")) //read R.A, R.B, S.B, S.C if R.B=S.B
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		if(i[1]==j[0])
		    		{
		    			ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(i[1]),new Datum.Int(j[0]), new Datum.Int(j[1])});
		    		}
		    	}    
		    }
	    }
  }
  
  
//conditional read of 3 files
  public static void readFile(File file1,File file2,File file3,int index1,int index2,String condition)throws Exception
  {
	    String thisLine1,thisLine2,thisLine3;
	    
	    FileInputStream fis1 = new FileInputStream(file1);
	    DataInputStream myInput1 = new DataInputStream(fis1);

	    FileInputStream fis2 = new FileInputStream(file2);
	    DataInputStream myInput2 = new DataInputStream(fis2);

	    FileInputStream fis3 = new FileInputStream(file3);
	    DataInputStream myInput3 = new DataInputStream(fis3);

	    List<Integer[]> ar1 = new ArrayList<Integer[]>();
	    List<Integer[]> ar2 = new ArrayList<Integer[]>();
	    List<Integer[]> ar3 = new ArrayList<Integer[]>();
	    
	    while ((thisLine1 = myInput1.readLine()) != null) 
	    {
	        String strar1[] = thisLine1.split(",");
	        ar1.add(new Integer[]{Integer.parseInt(strar1[index1]),Integer.parseInt(strar1[index2])});
	    }
	    while ((thisLine2 = myInput2.readLine()) != null) 
	    {
		    String strar2[] = thisLine2.split(",");
		    ar2.add(new Integer[]{Integer.parseInt(strar2[index1]),Integer.parseInt(strar2[index2])});
	    }
	    while ((thisLine3 = myInput3.readLine()) != null) 
	    {
		    String strar3[] = thisLine3.split(",");
		    ar3.add(new Integer[]{Integer.parseInt(strar3[index1]),Integer.parseInt(strar3[index2])});
	    }
	    
	    if(condition.equals("and"))	//conditional read
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		for(Integer[] k : ar3)
		    		{
		    			if((i[1]==j[0]) && (j[1]==k[0]))
		    			{
		    				ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(k[1])});
		    			}
		    		}
		    	}    
		    }
	    	
	    }
	    else if(condition.equals("join"))
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		for(Integer[] k : ar3)
		    		{
		    			if((i[1]==j[0]) && (j[1]==k[0]))
		    			{
		    				ret.add(new Datum[] {new Datum.Int(i[0]),new Datum.Int(i[1]),new Datum.Int(j[0]),new Datum.Int(j[1]),new Datum.Int(k[0]), new Datum.Int(k[1])});
		    			}
		    		}
		    	}    
		    }
	    	
	    }
	    else if(condition.equals("andLT"))
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		for(Integer[] k : ar3)
		    		{
		    			if((i[1]==j[0]) && (j[1] < k[0]))
		    			{
		    				ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(k[1])});
		    			}
		    		}
		    	}    
		    }
	    }
	    else if(condition.equals("andLT1"))
	    {
	    	for(Integer[] i : ar1)
		    {
		    	for(Integer[] j : ar2)
		    	{
		    		for(Integer[] k : ar3)
		    		{
		    			if((i[1]==j[0]) && (j[1] > k[0]))
		    			{
		    				ret.add(new Datum[] {new Datum.Int(i[0]), new Datum.Int(k[1])});
		    			}
		    		}
		    	}    
		    }
	    }
  }


  public static void readFile(File file,int index)throws Exception
  {
	    String thisLine;
	    int count = 0;
	    FileInputStream fis = new FileInputStream(file);
	    DataInputStream myInput = new DataInputStream(fis);

	    while ((thisLine = myInput.readLine()) != null) {
	        String strar[] = thisLine.split(",");
	        ret.add(new Datum[] {new Datum.Int(Integer.parseInt(strar[index]))});
	        }	
	}
  public static List<List<Datum[]>> execFile( File program )
    throws Exception
    { 
	 /* Map<String, Schema.TableFromFile> tables=null;
      PlanNode q=null;
      System.out.println("inside Part2"); 
      List<List<Datum[]>> expected = new ArrayList<List<Datum[]>>();
      expected.add(execQuery(tables,q));
      ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
      ret.add(new Datum[] {new Datum.Int(1)}); 
      expected.add(ret);
      return expected;*/ParserOutput parserOutput=null;
	  try{ 
			SqlParser parser = new SqlParser (new FileReader(program));  
			parserOutput = parser.initParser(); 
		    System.out.println(parserOutput.q);
		    System.out.println(parserOutput.tables);
		   
		   
		}
	  catch (Exception ex) 
			{ex.printStackTrace() ;} 
	  List<List<Datum[]>> expected = new ArrayList<List<Datum[]>>();
		      expected.add(execQuery(parserOutput.tables,parserOutput.q));
		   
		      return expected;
    }
}
